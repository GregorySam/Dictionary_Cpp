-----------1η ΕΡΓΑΣΙΑ ΣΥΣΠΡΟ----------------------
ΣΑΜΙΟΣ ΓΡΗΓΟΡΗΣ
1115201500141

------This is a dictionary written in cpp which outputs frequencies of words in texts-------------


-------------Compile-------------------------------------

make Minisearch

make clean

-------------Execute------------------------------------
/Minisearch -i (docfile) -k (number of results)
 commands:
	/search q1 q2 q3 	searches the most realted text with the words q1 q2 q3
	/df     		displays in how many text each word appears 
	/df (word)   		displays in how many texts the word appears
	/tf (id) (word) 	displays  how many times the (word) appears in (id) text
	/exit 			exit the application

-------------------Βασικές Δομές:

---------Λίστα:
Για την απεικόνηση κάθε είδους δομής συνδεδεμεης λίστας δημιούργησα ένα Template γενικής χρήσης.



--------Αποθήκευση Κειμένων:

Δημιοργία struct Document με το id και το κείμενο.Για την αποθήκευση των Document αρχικά διαβάζω όλο το αρχείο ελέγχοντας αν είναι σωστά τα ids και πέρνω το μέγεθος του πίνακα που θα δημιουργήσω.Δημιουργώ στατικό πίνακα με βάση το μέγεθος,ξαναδιαβαω το αρχείο από την αρχή και αποθηκεύω τα κείμενα.Το πλεονέκτημα αυτού του τρόπου είναι η δυνατότητα άμεσης πρόσβασης σε document με το id,καθώς και ότι ελέγχεται το αρχείο πριν αρχίσουν να δημιουργούνται οι δομές.


--------Trie:
--Κόμβος Trie:Αποτελείται από ένα δείκτη σε Λιστα με τα παδία του ,τον χαρακτήρα και ένα δείκτη σε posting list.Αν δεν έχει παιδιά ο κόμβος ή η posting list οι ποιντερς είναι NULL.Παρόλο που αυτή η δομή μπορεί να δεσμεύει +2*8 bytes(64-bit) για κάθε TrieNode όταν είναι NULL η υλοπόιηση του είναι εύκολη.

------Υπολογισμός Σκορ:
Για τον υπολογισμό των Σκορ ακολούθησα την εξής διαδικασία:Για κάθε λέξη αποθήκευσε το σκορ της με βάση τα docids και βάλτο σε μια struct τύπου DocScore [docid,score,char* index] αποθήκευσε αυτό το struct σε μια δυναμικά συνδεδεμένη Λίστα.Αφόυ τελειώσεις με όλες τις λέξεις μετέτρεψε την λίστα σε πίνακα κάνε quiksort ως προς τα docids .Στη συνέχεια συγχώνευσε σκορς με κοινά ids και τέλος κάνε πάλι quiksort ως προς τα σκορς.Η τελικη πολυπλοότητα αν θεωρήσουμε ότι έχουμε το πολυ 10 λέξεις με m documents και στην χειρότερη κάθε λέξη υπάρχει σε κάθε document τοτε θα είναι 2*Ο(10m)+2*O(10mlog(10m) στην χειρότερη περίπτωση.Παρόλο που είναι λιγο μεγαλύτερο από την πολυπλοκότητα του heap η υλοποίηση μου φάνηκε ευκολότερη.Το char* index είναι οι χαρακτήρες '^' που προσδιορίζουν το που βρίσκεται η λέξη μέσα στο συγκεκριμένο document.

 
